/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*-  */
/*
 * GeneralizedPropagator.cc
 * Copyright (C) 2015 Shahab Tasharrofi <shahab@pc41>
 *
 * minisat-general-propagators is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * minisat-general-propagators is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "GeneralizedPropagator.h"

#define noGEN_PROP_DEBUG

#ifdef GEN_PROP_DEBUG
#define noGEN_PROP_DEEP_DEBUG
#endif

#ifdef PROPAGATOR_DEBUG
#ifdef GEN_PROP_DEBUG
static const char *genBoolPropName = "bool";
#endif
#endif

bool GeneralizedPropagator::prepareReasonAndTriggers(bool computeTriggers)
{
	if (newSolverInstance->solve(assumptions))
	{
#ifdef GEN_PROP_DEBUG
		printf("generalized propagator (e: %d, i: %d): found model", SolverInstance->nClauses(), newSolverInstance->nClauses());
		for (int i = 0; i < newSolverInstance->model.size(); i++)
			printf(" "), newSolverInstance->printLiteral(stdout, mkLit(i, newSolverInstance->model[i] == l_False));
		printf(". generating a conflict\n");
#endif

		reasonLiterals.clear();
		if (reasonGenerator.size() > 0)
		{ // If reason generator contains literals, then it means that we know how to
			// generate the reasons
			for (auto it = reasonGenerator.cbegin(); it != reasonGenerator.cend(); it++)
			{
				if (reasonLiterals.hasMember((*it).first.x))
					continue;

				bool test = true;
				for (auto jt = (*it).second.cbegin(); jt != (*it).second.cend(); jt++)
					if (newSolverInstance->model[var(*jt)] != (sign(*jt) ? l_False : l_True))
					{
						test = false;
						break;
					}
				if (test)
					reasonLiterals.insert((*it).first.x);
			}
		}
		else
		{ // If not, the reason has to be generated from the clauses. The reason is
			// generated by taking one literal from each clause that is not satisfied
			// by internal variables of the solver. The literal should be such that it
			// satisfies the clause. The existence of such a literal is guaranteed by
			// the fact that we have found a model that satisfies all clauses.
			//
			// We then also add literals from the assumptions that explain the
			// satisfiability of solver's propagators. These are needed because the
			// solver might not have a complete axiomatization of the problem. This is
			// particularly true when QBF is going to be solved in a hierarchical
			// manner.
			auto findSatLiteral = [this](const Clause &C) -> Lit
			{
				Lit p = lit_Undef;
				for (int j = 0; j < C.size(); j++)
				{
					Lit l = C[j];
					if (reverseMapping.hasKey(var(l)))
					{
						Lit newLit = mkLit(reverseMapping.valueOf(var(l)), !sign(l));
						if (reasonLiterals.hasMember(newLit.x))
							return lit_Undef;
						else if (newSolverInstance->modelValue(l) == l_True)
							p = newLit;
					}
					else if (newSolverInstance->modelValue(l) == l_True)
						return lit_Undef;
				}
				assert(p != lit_Undef);
				return p;
			};

			int undefLiteralCount = 0;
			Lit lastUndefLiteral = lit_Undef;

#ifdef GEN_PROP_DEEP_DEBUG
			printf("generalized propagator: generating conflict clause\n");
#endif
			for (int i = 0; i < newSolverInstance->getPropagatorCount(); i++)
			{
				const vec<Lit> &propReason = newSolverInstance->getPropagator(i)->explain();
				for (int j = 0; j < propReason.size(); j++)
				{
					Lit p = propReason[j];
					if (reverseMapping.hasKey(var(p)))
					{ // If the reason has to do with our assumptions, we have to add it to
						// the reasonLiterals
						assert(newSolverInstance->modelValue(p) == l_True);
						Lit newLit = mkLit(reverseMapping.valueOf(var(p)), !sign(p));

						assert(SolverInstance->value(newLit) != l_True);
						if (SolverInstance->value(newLit) == l_Undef)
						{
							undefLiteralCount++;
							lastUndefLiteral = newLit;
						}

#ifdef GEN_PROP_DEEP_DEBUG
						printf("generalized propagator: adding literal ");
						SolverInstance->printLiteral(stdout, newLit);
						printf(" because of propagator explanation\n");
#endif
						reasonLiterals.insert(newLit.x);
					}
				}
			}

			for (int i = 0; i < newSolverInstance->nBoundVars(); i++)
			{
				Lit p = newSolverInstance->getBoundLitAt(i);
				if (reverseMapping.hasKey(var(p)))
				{ // If literal p is forced in the internal solver, it has to be present
					// in all reasons (because it is part of all hitting sets)
					assert(newSolverInstance->modelValue(p) == l_True);
					Lit newLit = mkLit(reverseMapping.valueOf(var(p)), !sign(p));

					assert(SolverInstance->value(newLit) != l_True);
					if (SolverInstance->value(newLit) == l_Undef)
					{
						undefLiteralCount++;
						lastUndefLiteral = newLit;
					}

#ifdef GEN_PROP_DEEP_DEBUG
					printf("generalized propagator: adding literal ");
					SolverInstance->printLiteral(stdout, newLit);
					printf(" because it is forced by the internal solver\n");
#endif
					reasonLiterals.insert(newLit.x);
				}
			}
#ifdef GEN_PROP_DEEP_DEBUG
			printf("generalized propagator: checking %d clauses from internal solver\n", newSolverInstance->nClauses());
#endif
			for (int i = 0; i < newSolverInstance->nClauses(); i++)
			{
				const Clause &c = newSolverInstance->getClause(i);
				Lit newLit = findSatLiteral(c);

				if (newLit != lit_Undef)
				{
					assert(SolverInstance->value(newLit) != l_True);
					if (SolverInstance->value(newLit) == l_Undef)
					{
						undefLiteralCount++;
						lastUndefLiteral = newLit;
					}

					reasonLiterals.insert(newLit.x);

#ifdef GEN_PROP_DEEP_DEBUG
					printf("generalized propagator: literal ");
					newSolverInstance->printLiteral(stdout, newLit);
					printf(" chosen because of clause ");
					for (int counter = 0; counter < c.size(); counter++)
					{
						newSolverInstance->printLiteral(stdout, c[counter]);
						printf(" ");
					}
					printf("\n");
#endif
				}
#ifdef GEN_PROP_DEEP_DEBUG
				else
				{
					printf("generalized propagator: no literal chosen from clause ");
					for (int counter = 0; counter < c.size(); counter++)
					{
						newSolverInstance->printLiteral(stdout, c[counter]);
						printf(" ");
					}
					printf("\n");
				}
#endif
			}

			assert(undefLiteralCount == 0);
		}

		return false;
	}
	else if (computeTriggers)
	{
#ifdef GEN_PROP_DEEP_DEBUG
		printf("generalized propagator (e: %d, i: %d): no model found. finding triggers\n", SolverInstance->nClauses(), newSolverInstance->nClauses());
#endif

		triggers.clear();
		for (int i = 0; i < newSolverInstance->conflict.size(); i++)
		{
			Lit p = newSolverInstance->conflict[i];
			assert(reverseMapping.hasKey(var(p)));
			Var origVar = reverseMapping.valueOf(var(p));

			// Upper bound variables only appear in negative places of the internal
			// formula and thus a negative literal p is related to an upperbound
			// variable and should thus be watched in negative.
			//
			// Similarly, lower bound variables only appear in positive places of
			// the internal formula and thus positive literal p should be watched
			// positively.
			//
			// In both cases, a literal should only be watched if its value differs
			// from its sign. That is positive variables should only be watched if
			// their value is not true and negative variables should only be watched
			// if their value is not false.

			Lit newLit = mkLit(origVar, sign(p));
			assert(SolverInstance->value(newLit) != l_True); // because it is part of the conflict
			triggers.insert(newLit.x);
		}
		triggersInitialized = true;
	}

	return true;
}

bool GeneralizedPropagator::performPropagations()
{
#ifdef GEN_PROP_DEEP_DEBUG
	printf("generalized propagator: performing propagations\n");
#endif

	if (!prepareReasonAndTriggers(true))
	{ // A solution was found and "reasonLiterals" contains the conflict clause that was derived from that solution
		/* In case that minimization is required, we do the following:
		 *
		 * Definitions
		 * -----------
		 * For a set V of variables, a function a:V --> {T,U,F} is a partial interpretation over variables V
		 * The set of all partial interpretations over variables V are shown by P(V)
		 *
		 * A partial intepretation a over variables V is said to be total if for all x in V, a(x) =/= U
		 * 
		 * For two partial interpretations a, a' in P(V), we say that a' is more precise than a (denoted by
		 * a <= a') if the two following conditions hold:
		 *   (1) for all x in V, a'(x) = U implies that a(x) = U
		 *   (2) for all x in V, a'(x) =/= U implies that a(x) = a'(x)
		 *
		 * For a set of variables V, a function f: P(V) --> {T,U,F} is a 3-valued characteristic function if
		 * the two following conditions hold:
		 *   (1) If a in P(V) is a total interpretation then f(a) =/= U
		 *   (2) If a, a' in P(V) are such that a <= a' and f(a) =/= U then f(a') = f(a)
		 *
		 * For a 3-valued characteristic function f, we say that a function g : P(V) --> (T, P(V)) + (U, .) + (F, P(V))
		 * witnesses f if the following conditions hold:
		 *   (1) For all S, f(S) = fst(g(S))
		 *   (2) If g(S) = (T, S') then S' <= S and f(S') = T
		 *   (3) If g(S) = (F, S') then S' <= S and f(S') = F
		 *
		 * Task
		 * ----
		 * Given a function g that witnesses a 3-valued characteristic function f and a partial interpretation
		 * S such that f(S) = T, we want to find a partial interpretation S' such that:
		 *   (1) S' <= S
		 *   (2) f(S') = T
		 *   (3) if S'' <= S' and S'' =/= S' then f(S'') = U
		 *
		 * Procedure 1 (does not track which x's are proved to be necessary)
		 * -----------------------------------------------------------------
		 * Input: f, g, S
		 * Guarantees:
		 *   (1) g witnesses f
		 *   (2) f(S) = T
		 * 1. (R, S') := g(S)
		 * 2. assert(R == T)
		 * 3. S := S'
		 * 4. For all x in S:
		 * 4.1. (R, S') := g(S\{x})
		 * 4.2. If R == T then
		 * 4.2.1. goto (3)
		 * 5. return S
		 *
		 * Procedure 2 (avoids repetitive call for x's that are proved to be necessary)
		 * ----------------------------------------------------------------------------
		 * Input: f, g, A
		 * Guarantees:
		 *   (1) g witnesses f
		 *   (2) f(A) = T
		 * 1. (R, S) := g(A)             # Compute satisfiability witness S for assumptions A
		 * 2. assert(R == T)             # Since f(A) = T, we should have g(A) = (T, _)
		 * 3. M := S                     # Set current unsure literals to S
		 * 4. A := S                     # Set current assumptions to S
		 * 5. C := {}                    # Set current certainly conflicting set to empty
		 * 6. While M =/= {}:            # While there is at least one unsure literal:
		 * 6.1. Choose l in M            # Choose one such literal
		 * 6.2. (R, S) := g(A \ {l})     # Check if, after removing that literal from assumptions, f is still sat
		 * 6.3. assert(R =/= F)          # f cannot be unsat (because f(A) is sat and A\{l} <= A)
		 * 6.4. If R == T then           # If f is sat then chosen literal l is not necessary
		 * 6.4.1. M := S \ C             # Remove from M all literals that have not been necessary (including l)
		 * 6.4.2. A := S                 # Set current assumption to only those that might be necessary
		 * 6.5. If R == U then           # If f is unknown then chosen literal l is necessary
		 * 6.5.1. M := M \ {l}           # Remove l from unsure literals M
		 * 6.5.2. C := C U {l}           # Add l to certainly necessary set of literals
		 * 7. return C                   # Return the obtained minimal set of conflicting literals C
		 */
		// An implementation of Procedure 2 above except that we can also control the maximum
		// number of calls to the internal solver
		reason.clearunboxed();

		int remainingTries = newSolverInstance->min_conflict_tries - 1;
		if (remainingTries > 0)
		{
			clearAllAssumptions();
			for (int i = reasonLiterals.begin(); i != reasonLiterals.end(); i = reasonLiterals.nextNumber(i))
				addAssumption(~mkLit(i >> 1, i & 1));

			while (reasonLiterals.begin() != reasonLiterals.end())
			{
				int lIndex = reasonLiterals.begin();
				Lit l = mkLit(lIndex >> 1, lIndex & 1);
				removeAssumption(~l);
				if (!prepareReasonAndTriggers(false))
				{
					clearAllAssumptions();
					for (int i = reasonLiterals.begin(); i != reasonLiterals.end(); i = reasonLiterals.nextNumber(i))
						addAssumption(~mkLit(i >> 1, i & 1));
					for (int i = 0; i < reason.size(); i++)
						reasonLiterals.remove(reason[i].x);
				}
				else
				{
					reason.push(l);
					addAssumption(~l);
					reasonLiterals.remove(l.x);
				}

				remainingTries--;
				if (remainingTries == 0)
					break;
			}

			// restoring assumptions
			for (int i = 0; i < propagationStartIndex; i++)
				addAssumption(getTrailLiteralAt(i));
		}

		for (int i = reasonLiterals.begin(); i != reasonLiterals.end(); i = reasonLiterals.nextNumber(i))
			reason.push(mkLit(i >> 1, i & 1));

		/*
		// An implementation of Procedure 1 above except that we can also control the maximum
		// number of calls to the internal solver
		int remainingTries = newSolverInstance->min_conflict_tries - 1;
		while (true)
		{
			bool shouldTryAgain = (remainingTries >= 1);
			reason.clearunboxed();
			if (shouldTryAgain)
				clearAllAssumptions();
			for (int i = reasonLiterals.begin(); i != reasonLiterals.end(); i = reasonLiterals.nextNumber(i))
			{
				Lit reasonLit = mkLit(i >> 1, i & 1);
				reason.push(reasonLit);
				if (shouldTryAgain)
					addAssumption(~reasonLit);
			}
			if (shouldTryAgain)
			{
				bool changed = false;
				for (auto it = reason.cbegin(); it != reason.cend(); it++)
				{
					remainingTries--;
					removeAssumption(~(*it));
					if (!prepareReasonAndTriggers())
					{
						changed = true;
						break;
					}
					addAssumption(~(*it));
					if (remainingTries == 0)
						break;
				}
				if (!changed)
					remainingTries = 0;
			}
			else
				break;
		}
		*/
		Propagator::Effect e = addNewClause(reason, false);
		return (e != CONFLICT);
	}

	return true; // No solution was found and triggers were initialized accordingly
}

GeneralizedPropagator::GeneralizedPropagator(Solver *S, Solver *internalSolver, bool completeEncoding,
																						 int externalSolverVarCount, int internalSolverVarCount,
                                             const vector< pair<int, int> > &upperboundMapping,
                                             const vector< pair<int, int> > &lowerboundMapping,
                                             const vector< pair<Lit, vector<Lit> > > &conditionalReasons)
	: TriggerProtectedPropagator(S),
		triggers(externalSolverVarCount * 2 + 3),
		reasonLiterals(externalSolverVarCount * 2 + 3),
		upperboundMap(externalSolverVarCount),
		lowerboundMap(externalSolverVarCount),
		reverseMapping(internalSolverVarCount),
		varToAssumptionIndex(internalSolverVarCount)
{
#ifdef PROPAGATOR_DEBUG
#ifdef GEN_PROP_DEBUG
	debuggingEnabled = true;
	propagatorName = genBoolPropName;
#endif
#endif
	newSolverInstance = internalSolver;
	hasCompleteEncoding = completeEncoding;

	assumptions.clear();
	currentAssumptionIndex = 0;
	upperboundMap.clear();
	for (auto it = upperboundMapping.cbegin(); it != upperboundMapping.cend(); it++)
	{
		upperboundMap.insert((*it).first, (*it).second);
		reverseMapping.insert((*it).second, (*it).first);
		varToAssumptionIndex.insert((*it).second, assumptions.size());
		assumptions.push(mkLit((*it).second));
	}

	lowerboundMap.clear();
	for (auto it = lowerboundMapping.cbegin(); it != lowerboundMapping.cend(); it++)
	{
		lowerboundMap.insert((*it).first, (*it).second);
		reverseMapping.insert((*it).second, (*it).first);
		varToAssumptionIndex.insert((*it).second, assumptions.size());
		assumptions.push(~mkLit((*it).second));
	}

	reasonGenerator.clear();
	for (size_t i = 0; i < conditionalReasons.size(); i++)
	{
		reasonGenerator.push_back(pair<Lit, vector<Lit> >(conditionalReasons[i].first, vector<Lit>()));
		reasonGenerator[i].first = conditionalReasons[i].first;
		for (size_t j = 0; j < conditionalReasons[i].second.size(); j++)
			reasonGenerator[i].second.push_back(conditionalReasons[i].second[j]);
	}

	triggers.clear();
	triggersInitialized = false;
}

bool GeneralizedPropagator::initialize(void)
{
	return true;
}

bool GeneralizedPropagator::propagate(int start, int end)
{
#ifdef GEN_PROP_DEEP_DEBUG
	printf("generalized propagator (e: %d, i: %d): propagating literals ", SolverInstance->nClauses(), newSolverInstance->nClauses());
	for (int i = start; i < end; i++)
		printf("%d ", ConvertLiteralToInt(getTrailLiteralAt(i)));
	printf("\n");
#endif

	for (int i = start; i < end; i++)
		addAssumption(getTrailLiteralAt(i));

	if (!triggersInitialized)
		return !performPropagations();
	else
	{
		bool test = false;
		for (int i = start; i < end; i++)
			if (triggers.hasMember(getTrailLiteralAt(i).x))
			{
				test = true;
				break;
			}

		if (test)
			return !performPropagations();
		else
		{
#ifdef GEN_PROP_DEEP_DEBUG
				printf("generalized propagator: performing propagation method was not necessary\n");
#endif
				return false;
		}
	}
}

bool GeneralizedPropagator::propagate(Lit p)
{
#ifdef GEN_PROP_DEEP_DEBUG
	printf("generalized propagator: propagating literal %d\n", ConvertLiteralToInt(p));
#endif
	addAssumption(p);
	if (!triggersInitialized || (triggers.hasMember(p.x)))
		return !performPropagations();
	else
	{
#ifdef GEN_PROP_DEEP_DEBUG
		printf("generalized propagator: performing propagation method was not necessary\n");
#endif
		return false;
	}
}

void GeneralizedPropagator::cancelUntil(int level)
{
	for (int i = propagationStartIndex - 1; i >= getTrailLimit(level); i--)
		removeAssumption(getTrailLiteralAt(i));
	triggersInitialized = false;
}

bool GeneralizedPropagator::isTheoryVar(Var v)
{
	return upperboundMap.hasKey(v) || lowerboundMap.hasKey(v);
}

const vec<Lit> &GeneralizedPropagator::explain()
{
#ifdef GEN_PROP_DEBUG
	printf("generalized propagator: explaining current model\n");
#endif
	// Initialize assumptions based on the current model found by the external solver
	explanationAssumptions.clear();
	for (int i = 0; i < SolverInstance->model.size(); i++)
	{
		if (upperboundMap.hasKey(i))
			explanationAssumptions.push(mkLit(upperboundMap.valueOf(i), SolverInstance->model[i] == l_False));
		if (lowerboundMap.hasKey(i))
			explanationAssumptions.push(mkLit(lowerboundMap.valueOf(i), SolverInstance->model[i] != l_True));
	}

	// Solve internal solver according to those assumptions. It should be UNSAT
	// because, if not, some conflict should have been returned previously and a
	// model should not have been found.
	if (newSolverInstance->solve(explanationAssumptions))
		assert(false); // Why is it satisfied? Did hell just break loose?

	// Now, explain satisfiability of this propagator according to the conflict
	// received from the internal solver
	reason.clear();
	for (int i = 0; i < newSolverInstance->conflict.size(); i++)
	{
		Lit p = newSolverInstance->conflict[i];
		assert(reverseMapping.hasKey(var(p)));
		Var origVar = reverseMapping.valueOf(var(p));

		Lit newLit = mkLit(origVar, !sign(p));
		assert(SolverInstance->modelValue(newLit) == l_True); // because it is the model value for the negation of a conflict literal 
		reason.push(newLit);
	}

#ifdef GEN_PROP_DEBUG
	printf("generalized propagator: explanation is ");
	for (int i = 0; i < reason.size(); i++)
		printf("%d ", ConvertLiteralToInt(reason[i]));
	printf("\n");
#endif

	return reason;
}

bool GeneralizedPropagator::triggersReady(void)
{
	return triggersInitialized;
}

const vec<Lit> &GeneralizedPropagator::getTriggers(void)
{
	reason.clearunboxed();
	for (int i = triggers.begin(); i != triggers.end(); i = triggers.nextNumber(i))
		reason.push(mkLit(i >> 1, i & 1));

	return reason;
}

Propagator *GeneralizedPropagator::copy(Solver *S)
{
	vector< pair<int, int> > upperboundMapping;
	vector< pair<int, int> > lowerboundMapping;
	vector< pair<Lit, vector<Lit> > > conditionalReasons = reasonGenerator;

	for (int i = 0; i < upperboundMap.capacity(); i++)
		if (upperboundMap.hasKey(i))
			upperboundMapping.push_back(pair<int, int>(i, upperboundMap.valueOf(i)));
	for (int i = 0; i < lowerboundMap.capacity(); i++)
		if (lowerboundMap.hasKey(i))
			lowerboundMapping.push_back(pair<int, int>(i, lowerboundMap.valueOf(i)));

	return new GeneralizedPropagator(S, newSolverInstance, hasCompleteEncoding, S->nVars(), newSolverInstance->nVars(), upperboundMapping, lowerboundMapping, conditionalReasons);
}

